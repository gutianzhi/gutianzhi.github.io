<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java网络编程-线程 | Guttttzhi'Blog</title><meta name="keywords" content="java,网络编程,线程"><meta name="author" content="Guttttzhi"><meta name="copyright" content="Guttttzhi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="java网络编程-线程">
<meta property="og:type" content="article">
<meta property="og:title" content="java网络编程-线程">
<meta property="og:url" content="http://example.com/2021/11/29/javanetwork/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Guttttzhi&#39;Blog">
<meta property="og:description" content="java网络编程-线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500">
<meta property="article:published_time" content="2021-11-29T06:43:04.000Z">
<meta property="article:modified_time" content="2021-11-30T07:38:02.863Z">
<meta property="article:author" content="Guttttzhi">
<meta property="article:tag" content="java">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/11/29/javanetwork/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java网络编程-线程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-30 15:38:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-filter-gitcalendar/lib/gitcalendar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/hero.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=454715195,1460490061&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=501&amp;h=500')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Guttttzhi'Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java网络编程-线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-29T06:43:04.000Z" title="发表于 2021-11-29 14:43:04">2021-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-30T07:38:02.863Z" title="更新于 2021-11-30 15:38:02">2021-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">java网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java网络编程-线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="线程创建的方式"><a href="#线程创建的方式" class="headerlink" title="线程创建的方式"></a>线程创建的方式</h1><ol>
<li>实现Runnable接口</li>
<li>继承Thread类</li>
<li>实现Callable接口的类</li>
</ol>
<h1 id="实现Runable接口的类"><a href="#实现Runable接口的类" class="headerlink" title="实现Runable接口的类"></a>实现Runable接口的类</h1><ol>
<li>写一个Runnable接口的实现类</li>
<li>实现run方法</li>
<li>创建该实现类的对象</li>
<li>创建Thread对象，并将实现类对象作为参数来构造Thread对象</li>
<li>执行Thread对象的start（）方法，启动线程。</li>
</ol>
<p><strong>tips</strong>：同一个类对象创建多个线程，多个线程共享类中的成员变量。</p>
<h1 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h1><ol>
<li>写一个类，继承Thread类。</li>
<li>重写run方法</li>
<li>创建给类对象</li>
<li>执行该类对象的start（）方法，启动线程</li>
</ol>
<p><strong>tips</strong>：同一个类对象创建多个线程，多个线程想共享同一个类中的成员变量，该成员变量必须是静态的。</p>
<h1 id="实现Callable接口的类"><a href="#实现Callable接口的类" class="headerlink" title="实现Callable接口的类"></a>实现Callable接口的类</h1><p>前面讲的Runnable接口顾名思义就是可以运行的意思，它声明了一个void run()方法，run()方法可以运行代码，但没有返回值。若希望一个线程运行完后有返回值，那么Runnable接口就解决不了，因此JDK1.5提供了Callable接口来完成该任务。<br>java.util.concurrent<br>@FunctionalInterface        //函数式接口<br> public interface Callable<V> {<br>     V call() throws Exception;<br>  }</p>
<h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	MyCallable(<span class="keyword">int</span> num)&#123;</span><br><span class="line">	    	<span class="keyword">this</span>.num=num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">			sum+=i;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Callable接口的类如何生成线程并启动线程呢？ 注意：不能用<span class="keyword">new</span> Thread()来创建线程，Thread构造函数中只能使用Runnable对象。</span><br><span class="line">Callable的线程任务可以用线程池的submit()方法提交给线程池中的线程去执行，还可以使用Future接口</span><br></pre></td></tr></table></figure>

<h1 id="线程的管理"><a href="#线程的管理" class="headerlink" title="线程的管理"></a>线程的管理</h1><ol>
<li>sleep(long mills):在指定的毫秒内让当前”正在执行的线程”休眠（暂停执行）。根据JDK API的说法，“该线程不丢失任何监视器的所属权”，简单说就是sleep代码上下文如果被加锁了，锁依然在，但是CPU资源会让出给其他线程.</li>
<li>setPriority(int); 设置线程优先级，Java线程优先级为1-10，数值越大优先级越高，默认优先级为5。由于Java采用的抢占式调度算法，优先级越高的线程抢到CPU的机会较多一点，但不是绝对的，即优先级高的线程不一定优先执行，当执行次数较多时，才有一定的效果。</li>
<li>getPriority()；获取线程的优先级</li>
<li>join();等待该线程结束后，其它线程才能抢CPU。join()放在某线程启动后执行。若希望几个线程串行执行，则需使用join()方法对线程管理.</li>
<li>yield()；线程礼让，让出CPU，让其它线程获取CPU，当然有可能它又抢到CPU</li>
<li>interrupt();中断线程</li>
<li>setDaemon(true); 设置为守护线程</li>
</ol>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="线程安全问题的条件"><a href="#线程安全问题的条件" class="headerlink" title="线程安全问题的条件"></a>线程安全问题的条件</h2><ul>
<li>是否是多线程。</li>
<li>是否有共享数据。</li>
<li>操作有多条语句操作共享数据。<h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3>使用同步锁将操作共享数据的代码进行包裹。<br>java同步机制的基本使用方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">  	需要同步的代码块；</span><br><span class="line">&#125;</span><br><span class="line">- 对象为任意对象（锁对象），但是要保证锁的唯一性。</span><br></pre></td></tr></table></figure>
以下实现卖票线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  <span class="keyword">int</span> tickets=<span class="number">100</span>;   <span class="comment">//定义100张票</span></span><br><span class="line"><span class="keyword">private</span> Object obj=<span class="keyword">new</span> Object();  <span class="comment">//定义同一把锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	        <span class="keyword">synchronized</span>(obj)&#123; <span class="comment">//所有线程执行到这里时判断锁对象是否可用，若不能用，线程进入阻塞状态，</span></span><br><span class="line">			<span class="comment">//若可用，则执行下面代码块，代码块执行完后，释放锁</span></span><br><span class="line">	            <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		     Thread.sleep(<span class="number">100</span>);   <span class="comment">//当前线程进入睡眠（阻塞)，不释放锁</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		 e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在出售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">	            &#125;</span><br><span class="line">                        &#125;  <span class="comment">//释放锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3>锁对象是线程对象本身<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	    e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在出售第&quot;</span>+tickets--+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;	</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在jdk5中提供专门的锁对象</span><br><span class="line"><span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();  <span class="comment">//创建锁对象</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	lock.lock();  <span class="comment">//获取锁</span></span><br><span class="line">	<span class="keyword">if</span>(tickets&lt;<span class="number">100</span>)&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+“正在出售第”+（++tickets）+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	lock.unlock();<span class="comment">//释放锁   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>锁必须是同一把锁。</li>
<li>在代码块上加同步锁（任意对象都可以作为锁对象）</li>
<li>在方法上加同步锁（普通方法上使用的锁是this，静态方法使用的锁对象是该类的class对象,比如SellTicket.class对象锁）</li>
</ol>
<h1 id="线程等待与唤醒"><a href="#线程等待与唤醒" class="headerlink" title="线程等待与唤醒"></a>线程等待与唤醒</h1><h2 id="生产线程"><a href="#生产线程" class="headerlink" title="生产线程"></a>生产线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">生产线程类的核心代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Produce</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; list;  <span class="comment">//存放产品的容器（生产线程和消费线程共享）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Produce</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.list=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">	    <span class="keyword">synchronized</span>(list) &#123;   	<span class="comment">//由于list是共享资源，一定要用同步</span></span><br><span class="line">    		<span class="keyword">if</span>(list.size()==<span class="number">10</span>)&#123;</span><br><span class="line">		    list.wait();       <span class="comment">//若容器里的产品数量达到10，生产线程等待，同时释放锁，让消费线程可以去获取到锁</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    Product p=<span class="keyword">new</span> Product(…);</span><br><span class="line">		    list.add(p);</span><br><span class="line">		    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		    list.notifyAll();     	<span class="comment">//唤醒等待线程 ，这里一般是消费线程</span></span><br><span class="line"> 		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="消费线程"><a href="#消费线程" class="headerlink" title="消费线程"></a>消费线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">消费线程类的核心代码：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consume</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; list;  <span class="comment">//存放产品的容器（生产线程和消费线程共享）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consume</span><span class="params">(List&lt;Product&gt; list)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.list=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">	    <span class="keyword">synchronized</span>(list) &#123;   	<span class="comment">//由于list是共享资源，一定要用同步</span></span><br><span class="line">    		<span class="keyword">if</span>(list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">		    list.wait();       <span class="comment">//若容器里没有产品，消费线程等待，同时释放锁，让其它线程可以去获取到锁</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    Product p=list.get(<span class="number">0</span>);    list.remove(<span class="number">0</span>); </span><br><span class="line">		    System.out.println(p);</span><br><span class="line">		    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		    list.notifyAll();     	<span class="comment">//唤醒等待线程 </span></span><br><span class="line"> 		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>为什么需要用线程池？<br>1、降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；<br>2、提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；<br>3、方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成CPU过度切换（CPU切换线程是有时间成本的，需要保持当前执行线程的现场，并恢复要执行线程的现场）。<br>4、提供更强大的延时定时线程池。<br>网络编程中著名的那些框架都是使用线程池，既解决高并发，高吞吐又控制服务器资源，不会因为无限制的创建线程导致系统崩溃。</p>
<h2 id="线程池工作原理-线程复用原理"><a href="#线程池工作原理-线程复用原理" class="headerlink" title="线程池工作原理:线程复用原理"></a>线程池工作原理:线程复用原理</h2><p>假设有10个任务，有2个工人，让2个工人去执行这10个任务，这就是线程复用原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id=id;</span><br><span class="line">		System.out.println(“第”+id+”个任务产生了”);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“第”+id+”个任务正在执行…”);</span><br><span class="line">		Thread.sleep(<span class="number">3000</span>); <span class="comment">//执行时间</span></span><br><span class="line">		 System.out.println(“第”+id+”个任务执行完毕。”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="title">implement</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	List tasks;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(List tasks)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tasks=tasks;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tasks.size()==<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">synchronized</span>(tasks)&#123;</span><br><span class="line">					System.out.println(“worker”+name+”没有任务”);</span><br><span class="line">					tasks.wait(); <span class="comment">//等待</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span>(tasks)&#123;</span><br><span class="line">				System.out.println(“worker”+name+”得到任务”);</span><br><span class="line">				tasks.removefirst().run();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List tasks=<span class="keyword">new</span> ArrayList&lt;Task&gt;();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(tasks))).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(tasks))).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Factory(tasks))).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="核心类：ThreadPoolExecutor"><a href="#核心类：ThreadPoolExecutor" class="headerlink" title="核心类：ThreadPoolExecutor"></a>核心类：ThreadPoolExecutor</h2><p>它提供了4个构造方法：<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>            BlockingQueue<Runnable> workQueue);<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>            BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>            BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</p>
<p>前面三个构造方法都是调用第四个构造方法实现。详细看第四个构造方法：<br>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,<br>        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);<br>1、corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到workQueue队列当中；<br>2、maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；<br>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。<br>4、workQueue（任务队列）：提交的线程任务先由核心线程执行，若任务超过核心线程数，则多余的任务放到等待执行任务的阻塞队列。然后从任务队列中去取任务，创建线程去执行。队列分有界队列和无界队列，若是有界队列，线程池的线程达到最大线程数，而且队列也满了，新来的任务如何处理？由线程饱和策略（第6个参数决定)。<br>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。<br>6、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p>
<h2 id="任务阻塞队列："><a href="#任务阻塞队列：" class="headerlink" title="任务阻塞队列："></a>任务阻塞队列：</h2><p>java.util.AbstractQueue<br>1、ArrayBlockingQueue：数组构成的有界队列<br>2、LinkedBlockingQueue：链表构成的有界/无界队列<br>3、PriorityBlockingQueue：支持优先级的有界队列<br>4、LinkedBlockingDeque：双向链表的有界/无界队列<br>5、SynchronousQueue：同步移交队列，无元素的队列，希望任务直接由线程执行，newCachedThreadPool采用的队列。<br>一般使用2、5。</p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>ThreadPoolExecutor.AbortPolicy():丢弃任务并抛出RejectedExecutionException异常。<br>ThreadPoolExecutor.DiscardPolicy()：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy()：由调用线程处理该任务 </p>
<h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><h2 id="如何配合线程池"><a href="#如何配合线程池" class="headerlink" title="如何配合线程池"></a>如何配合线程池</h2><p>CPU密集型任务尽量使用较小的线程池，一般为CPU核心数+1。 因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，会造成CPU过度切换。<br>IO密集型任务可以使用稍大的线程池，一般为2*CPU核心数。 IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候有其他线程去处理别的任务，充分利用CPU时间。<br>混合型任务可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。Netty框架采用boss线程组负责accept()，work线程组负责IO</p>
<h2 id="Executors类-工具类-注意：与Executor接口不同"><a href="#Executors类-工具类-注意：与Executor接口不同" class="headerlink" title="Executors类(工具类) 注意：与Executor接口不同"></a>Executors类(工具类) 注意：与Executor接口不同</h2><p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）<br>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）<br>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。<br>4、newScheduledThreadPool：适用于执行延时或者周期性任务。</p>
<ol>
<li>LinkedBlockingQueue对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为只有队列满了后才会触发生成多于核心线程数的线程。</li>
<li>SynchronousQueue第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</li>
<li>DelayedWorkQueue第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。Netty采用ScheduledThreadPool</li>
</ol>
<h2 id="简单的使用-1"><a href="#简单的使用-1" class="headerlink" title="简单的使用"></a>简单的使用</h2><p>任务线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、用核心线程池类创建线程池，掌握<span class="number">7</span>个参数的使用及它们之间的关系。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;      <span class="comment">//线程任务</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;当前执行的线程：&quot;</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	ThreadPoolExecutor executor=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">3</span>,<span class="number">60</span>,TimeUnit.SECONDS,</span><br><span class="line">	    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>),<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		executor.execute(<span class="keyword">new</span> Task(<span class="string">&quot;线程&quot;</span>+i));</span><br><span class="line">	&#125;</span><br><span class="line">	executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、用Executor提供的固定线程数量的线程池和缓冲线程池来执行前面的任务。</span><br><span class="line">newFixedThreadPool(<span class="number">2</span>),coreThreadNum <span class="number">2</span>,maxnumThreadNum <span class="number">2</span>, 采用无界的阻塞队列<span class="function">LinkedBlockQueue</span></span><br><span class="line"><span class="function"><span class="title">newCachedThreadPool</span><span class="params">()</span>，线程数最大数是Integer.MAX_VALUE，线程数无控制，队列是SynchronousQueue，无元素队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class ThreadPoolDemo2 </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService executor=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			executor.execute(<span class="keyword">new</span> Task(<span class="string">&quot;线程&quot;</span>+i));</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">上面我们用的是ExecutorService的execute()方法给线程池提交的Runnable任务，ExecutorService中还有一个submit()方法也可以向线程池提交任务，它既可以提交Runnable任务，还可以提交Callable任务，提交完后还返回一个Future对象，通过Future对象还可以查看线程的执行状态和返回结果。</span><br></pre></td></tr></table></figure>
<h1 id="Future接口（异步执行线程控制）"><a href="#Future接口（异步执行线程控制）" class="headerlink" title="Future接口（异步执行线程控制）"></a>Future接口（异步执行线程控制）</h1><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;  </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;  </span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;  </span><br><span class="line">        <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;  </span><br><span class="line">        <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。<br>V get(Long timeout , TimeUnit unit) ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。<br>boolean isDone() ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。<br>boolean isCanceller() ：如果任务完成前被取消，则返回true。<br>boolean cancel(boolean mayInterruptRunning) ：如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。<br>通过方法分析我们也知道实际上Future提供了3种功能1）能够中断执行中的任务（2）判断任务是否执行完成（3）获取任务执行完成后额结果。</p>
<h2 id="RunnableFuture接口"><a href="#RunnableFuture接口" class="headerlink" title="RunnableFuture接口"></a>RunnableFuture接口</h2><p>RunnableFuture接口继承了Runnable和Future接口；（注意：Java里类之间只能单继承，是为了避免多个父类中有重复的方法时，子类对象不知道调用的是哪个父类中的方法。而接口允许继承多个接口，原因是接口中只是方法的声明，没有实现。实现是靠子接口的实现类来完成，同一方法只会实现一次。）<br>public interface RunnableFuture<V> extends Runnable, Future<V> {<br>        void run();<br>}<br>RunnableFuture接口继承了Runnable接口和Future接口，意味着它的实现类既要实现Runnable中run()方法，还实现了Future接口中的V get()、cancel()、isDone()、isCancel()等方法。</p>
<h2 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h2><p>FutureTask类是RunnableFuture的实现类，FutureTask有两种构造方法：<br>public FutureTask(Callable<V> callable)<br>public FutureTask(Runnable runnable, V result)<br>既可以封装Runnable对象，也可以封装Callable对象，同时它是实现了Runnable接口的对象，该对象就可以用new Thread()来创建线程了。也可以用线程池的submit方法直接提交Runnable任务和Callable任务。</p>
<h2 id="用Thread执行Runnable任务、Callable任务："><a href="#用Thread执行Runnable任务、Callable任务：" class="headerlink" title="用Thread执行Runnable任务、Callable任务："></a>用Thread执行Runnable任务、Callable任务：</h2><p>FutureTask  ft1=new FutureTask(new MyRunnable(),null);<br>FutureTask<Integer>  ft2=new FutureTask<Integer>(new MyCallable(10));<br>new Thread(ft1).start();  //ft1任务的线程开始<br>new Thread(ft2).start();  //ft2任务的线程开始<br>ft1.get();    //等待ft1结束，返回值为null<br>int result=ft2.get();  //等待ft2结束，返回值为int。</p>
<h2 id="用ExecutorService线程池的submit-提交Runnable、Callable任务："><a href="#用ExecutorService线程池的submit-提交Runnable、Callable任务：" class="headerlink" title="用ExecutorService线程池的submit()提交Runnable、Callable任务："></a>用ExecutorService线程池的submit()提交Runnable、Callable任务：</h2><p>ExecutorService pool = Executors.newFixedThreadPool(2);<br>Future<Integer> ft1 = pool.submit(new MyCallable(10));<br>Future ft2=pool.submit(new MyRunnable());<br>ft1.get();   //等待线程结束，返回线程运行结果，int<br>ft2.get();   //等待线程结束，返回的结果为null<br>用ExecutorService线程池的execute()只能提交Runnable任务</p>
<h1 id="CountDownLatch-倒计数锁的使用"><a href="#CountDownLatch-倒计数锁的使用" class="headerlink" title="CountDownLatch(倒计数锁的使用)"></a>CountDownLatch(倒计数锁的使用)</h1><p>任务：编写程序，模拟4个短跑选手参加短跑比赛的场景。<br>假设主线程为裁判员，Runner为短跑比赛过程，比赛结束时，要返回每个选手的比赛时间，因此Runner需要实现Callable接口。主线程中创建4个选手线程，但4个线程不能一提交就开始运行，必须等裁判员发出起跑指令后才能开始运行。某线程结束后，裁判不能立即宣布某选手的跑步时间，需要等所有选手到达终点后才能宣布比赛结果。<br>分析：创建两个倒计数锁，一个用于发起跑信号，一个用于判断所有选手都到达终点的信号。</p>
<p>选手线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CountDownLatch startSignal;     	<span class="keyword">private</span> CountDownLatch endSignal;  	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Runner</span><span class="params">(CountDownLatch startSignal, CountDownLatch endSignal,String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.startSignal=startSignal;  		<span class="keyword">this</span>.endSignal=endSignal;   	<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;		</span><br><span class="line">			System.out.println(<span class="string">&quot;选手&quot;</span>+name+<span class="string">&quot;正在等待起跑指令..&quot;</span>);</span><br><span class="line">			startSignal.await();  <span class="comment">//线程等待起跑指令</span></span><br><span class="line">			System.out.println(<span class="string">&quot;选手&quot;</span> +name+ <span class="string">&quot;已接受裁判口令&quot;</span>);</span><br><span class="line">			<span class="keyword">long</span> result=(<span class="keyword">long</span>)(Math.random()*<span class="number">1000</span>);	</span><br><span class="line">			Thread.sleep(result);</span><br><span class="line">			System.out.println(<span class="string">&quot;选手&quot;</span>+name+<span class="string">&quot;到达终点&quot;</span>);</span><br><span class="line">			endSignal.countDown();   <span class="comment">//当前线程完成，endSignal计数器减1</span></span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;<span class="keyword">catch</span>( Exception e)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch startSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);<span class="comment">//选手线程等待主线程发出起跑指令</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch endSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">4</span>);<span class="comment">//主线程等待选手线程结束</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ExecutorService pool=Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">		Future&lt;Long&gt; runner1=pool.submit(<span class="keyword">new</span> Runner(startSignal,endSignal,<span class="string">&quot;wang&quot;</span>));</span><br><span class="line">		Future&lt;Long&gt; runner2=pool.submit(<span class="keyword">new</span> Runner(startSignal,endSignal,<span class="string">&quot;li&quot;</span>));</span><br><span class="line">		Future&lt;Long&gt; runner3=pool.submit(<span class="keyword">new</span> Runner(startSignal,endSignal,<span class="string">&quot;zhang&quot;</span>));</span><br><span class="line">		Future&lt;Long&gt; runner4=pool.submit(<span class="keyword">new</span> Runner(startSignal,endSignal,<span class="string">&quot;chen&quot;</span>));</span><br><span class="line">		<span class="comment">//主线程开始</span></span><br><span class="line">		<span class="keyword">try</span> &#123;	</span><br><span class="line">			System.out.println(<span class="string">&quot;主线程发布起跑指令...&quot;</span>);</span><br><span class="line">			startSignal.countDown();</span><br><span class="line">			System.out.println(<span class="string">&quot;主线程等待子线程完成&quot;</span>);</span><br><span class="line">			endSignal.await();</span><br><span class="line">			System.out.println(<span class="string">&quot;选手wang完成时间：&quot;</span>+(<span class="keyword">long</span>)runner1.get());</span><br><span class="line">			System.out.println(<span class="string">&quot;选手li完成时间：&quot;</span>+(<span class="keyword">long</span>)runner2.get());</span><br><span class="line">			System.out.println(<span class="string">&quot;选手zhang完成时间：&quot;</span>+(<span class="keyword">long</span>)runner3.get());</span><br><span class="line">			System.out.println(<span class="string">&quot;选手chen完成时间：&quot;</span>+(<span class="keyword">long</span>)runner4.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Guttttzhi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/29/javanetwork/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/">http://example.com/2021/11/29/javanetwork/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Guttttzhi'Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=454715195,1460490061&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=501&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/30/javanetwork/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Socket%E7%BC%96%E7%A8%8B/"><img class="prev-cover" src="https://img0.baidu.com/it/u=454715195,1460490061&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=501&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java网络编程-Socket编程</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/29/BUG/bug3/"><img class="next-cover" src="https://img0.baidu.com/it/u=454715195,1460490061&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=501&amp;h=500" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">bug3</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/13/javanetwork/java网络编程-AIO编程/" title="java网络编程-AIO编程"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-13</div><div class="title">java网络编程-AIO编程</div></div></a></div><div><a href="/2021/12/20/javanetwork/java网络编程-RMI编程/" title="java网络编程-RMI编程"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-20</div><div class="title">java网络编程-RMI编程</div></div></a></div><div><a href="/2021/11/25/javanetwork/java网络编程-石头剪刀布/" title="java网络编程-石头剪刀布"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">java网络编程-石头剪刀布</div></div></a></div><div><a href="/2021/12/13/javanetwork/java网络编程-NIO编程/" title="java网络编程-NIO编程"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-13</div><div class="title">java网络编程-NIO编程</div></div></a></div><div><a href="/2021/11/30/javanetwork/java网络编程-Socket编程/" title="java网络编程-Socket编程"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">java网络编程-Socket编程</div></div></a></div><div><a href="/2021/12/01/23种设计模式/" title="23种设计模式"><img class="cover" src="https://img0.baidu.com/it/u=454715195,1460490061&fm=253&fmt=auto&app=120&f=JPEG?w=501&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-01</div><div class="title">23种设计模式</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">线程创建的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">实现Runable接口的类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">实现Callable接口的类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">简单的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">线程的管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">6.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">线程安全问题的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">解决方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">6.2.1.</span> <span class="toc-text">同步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.3.</span> <span class="toc-text">锁对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">7.</span> <span class="toc-text">线程等待与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">生产线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">消费线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E7%BA%BF%E7%A8%8B%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">线程池工作原理:线程复用原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%EF%BC%9AThreadPoolExecutor"><span class="toc-number">8.2.</span> <span class="toc-text">核心类：ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">8.3.</span> <span class="toc-text">任务阻塞队列：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">8.4.</span> <span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.5.</span> <span class="toc-text">线程池的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">8.6.</span> <span class="toc-text">如何配合线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executors%E7%B1%BB-%E5%B7%A5%E5%85%B7%E7%B1%BB-%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%B8%8EExecutor%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%90%8C"><span class="toc-number">8.7.</span> <span class="toc-text">Executors类(工具类) 注意：与Executor接口不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-number">8.8.</span> <span class="toc-text">简单的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Future%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">Future接口（异步执行线程控制）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">9.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunnableFuture%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.2.</span> <span class="toc-text">RunnableFuture接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FutureTask%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">FutureTask类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8Thread%E6%89%A7%E8%A1%8CRunnable%E4%BB%BB%E5%8A%A1%E3%80%81Callable%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">用Thread执行Runnable任务、Callable任务：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8ExecutorService%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84submit-%E6%8F%90%E4%BA%A4Runnable%E3%80%81Callable%E4%BB%BB%E5%8A%A1%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">用ExecutorService线程池的submit()提交Runnable、Callable任务：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CountDownLatch-%E5%80%92%E8%AE%A1%E6%95%B0%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">CountDownLatch(倒计数锁的使用)</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://img0.baidu.com/it/u=454715195,1460490061&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=501&amp;h=500')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Guttttzhi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="biu,biu,biu" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
                        function gitcalendar_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html)
                          console.log('已挂载gitcalendar')
                          }

                        if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
                            gitcalendar_injector_config()
                            GitCalendarInit("https://gitcalendar.akilar.top/api?gutianzhi",['#ebedf0', '#f0fff4', '#dcffe4', '#bef5cb', '#85e89d', '#34d058', '#28a745', '#22863a', '#176f2c', '#165c26', '#144620'],'gutianzhi')
                        }
                      </script><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>